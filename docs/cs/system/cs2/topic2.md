---
counter: True
comment: True
---

# 操作系统简介

!!! abstract
    计算机系统 Ⅱ 第 7 至 8 周课程内容

## 中断和陷阱
### 硬件中断
- 外部 IO 设备有事情要通知 CPU 进行处理，通过中断完成
- 硬件部分：
    - CPU 内部有中断控制器
    - IO 通过硬件连线向中断控制器发送信号
    - CPU 发现有中断在 pending
    - CPU 将 pc 设置为中断向量开始的位置
- 软件部分：
    - 跳转的位置存放了中断处理程序（Interrupt Service Routine，ISR）
    - 关掉中断（不希望在处理中断的时候再次出现中断时被 CPU 跳转 pc）
    - 检查目前是什么中断，并且 dispatch 到指定的处理程序（interrupt handler）
    - 上下文处理：
        - 在中断处理前要保存上下文（pc 等系列寄存器）
        - 处理后恢复上下文，继续执行原来程序

### 陷阱
- trap，又叫软中断（soft interrupt）
- 硬件中断，由硬件产生，有外设硬件事件要处理
    - 是一个异步事件（asynchronous），即无法预测出现的时间
- trap 由软件产生，可能是运行出现了错误或者用户显式地请求中断
    - 是一个同步时间（synchronous）
    - 例如：系统调用，divided-by-zero 异常……

操作系统是 interrupt-driven 的

- 特殊的中断：计时器中断
- 定时产生计时器中断，让操作系统内核得到机会运行，进行评估、调度
- 否则如果没有其它中断产生，则用户态程序会一直运行占用资源，操作系统也没有机会介入管理

### 中断处理
- 先进行 CPU 执行状态的保存
    - 将 pc 等寄存器保存在内存中
- 两种处理机制
    - vectored interrupt system：
        - 硬件中断产生不会到统一的地址
        - 记录一个中断向量基地址，后面依次存储各个中断号对应的处理程序地址
        - 直接根据中断号来计算偏移，跳转到对应的处理程序中
    - polling：
        - 所有中断都跳转到统一的地址
        - 由软件来区分中断种类，决定如何处理等
- 处理后恢复执行状态
    - 恢复 pc 等寄存器，继续回去执行
    - 或者恢复其它进程的寄存器，实现调度

## I/O 处理
- 用户态程序想要操作外设
    - 通过系统调用（system call）来告诉 CPU 要操作外设
- 操作系统通过 MMIO（Memory Mapping I/O）来操纵外设
- 两种支持的 I/O 处理方式：
    - 同步 I/O（synchronous I/O）：进行 I/O 的时候 block 掉当前请求 I/O 的程序，等待 I/O 结束（可能会调度运行另一个程序）
        - 常用，易用，但不高效
    - 异步 I/O（asynchronous I/O）：即使 I/O 没有完成，仍然继续运行原程序，当 I/O 完成时，执行用户态定义的 callback 回调函数
        - 高效，常用于处理大量网络请求时

## DMA
- 比如 CPU 想让显卡在显示器上显示数据
    - 正常情况
        - CPU 将大量数据依次搬运到显卡对应的内存空间上
        - 期间 CPU 只做这一件事，无法运行其它程序
    - 通过 DMA（Direct Memory Access）
        - CPU 告诉显卡的 DMA 控制器要搬运的数据在哪、有多长
        - DMA 控制器会进行大量数据的搬运
        - 此时 CPU 可以进行其它运算
        - 完成后通过中断来通知 CPU
- 有 DMA 可以在没有 CPU 参与的情况下进行大量数据的搬运
- 问题
    - 各个设备都有自己的 DMA 控制器，在 DMA 控制器进行数据搬运的时候全部的物理内存都暴露给了外设
        - 通过内存和 DMA 直接额外的硬件 IOMMU（I/O 内存管理单元）来控制可以访问哪些物理内存
    
## 多模式操作
- 两个模式（也有更多的）
    - 用户态（user mode）
    - 内核态（kernel mode）
- CPU 中会存储相应值来记录当前的模式
- 一些指令是有特权级的，只能在内核态执行
- system call
    - 通过 trap 来转到内核态
    - 在 kernel 中执行指定操作
    - 再返回用户态继续执行

## 另一个视角
- 程序运行时 OS 在干什么
    - 使程序正常运行
    - 允许程序使用、共享存储
    - 允许程序和外设进行沟通
- 在做“虚拟化”（Virtualization）的事情
    - 给用户态程序提供虚拟的运行环境
    - 使用户态程序认为自己可以拥有全部 CPU 资源、IO 资源等
- 程序可以通过 syscall 来与 OS 打交道

~~嘛，后面还有一堆感觉很长时间内不会用到、不会学到的导论内容，就不记了~~